import matplotlib.patches as patches# The base class for all flowchart elements.class FlowElement:    def __init__(self, label=""):        self.label = label  # The label to be displayed on the flowchart element        self.x = None  # The x-coordinate of the element's position        self.y = None  # The y-coordinate of the element's position        self.grid_position = None  # The position of the element in the grid    # Draws the flowchart element. This is overridden by subclasses to provide specific drawing implementations.    def draw(self, ax, x, y, text_size):        pass    # Sets the position of the flowchart element on the canvas.    def set_position(self, x, y, grid_position=None):        self.x = x        self.y = y        self.grid_position = grid_position  # Stores the grid position for later reference    # Overridden by subclasses to calculate the starting offset of connection arrows.    def arrow_start_offset(self, other):        return 0, 0    # Overridden by subclasses to calculate the ending offset of connection arrows.    def arrow_end_offset(self, other):        return 0, 0# Represents a process step in the flowchart, drawn as a rectangle.class Process(FlowElement):    WIDTH = 0.15  # The width of the rectangle    HEIGHT = 0.1  # The height of the rectangle    # Draws the process rectangle and its label on the canvas.    def draw(self, ax, x, y, text_size):        rect = patches.Rectangle((x - self.WIDTH/2, y - self.HEIGHT/2), self.WIDTH, self.HEIGHT, edgecolor='black', facecolor='none')        ax.add_patch(rect)        ax.text(x, y, self.label, horizontalalignment='center', verticalalignment='center', fontsize=text_size)            def arrow_start_offset(self, other):        if other.grid_position is not None and self.grid_position is not None:            row_diff = other.grid_position[0] - self.grid_position[0]            col_diff = other.grid_position[1] - self.grid_position[1]            if col_diff > 0:  # if the other element is to the right                return self.WIDTH/2, 0            elif col_diff < 0:  # if the other element is to the left                return -self.WIDTH/2, 0            elif row_diff > 0:  # if the other element is below                return 0, -self.HEIGHT/2            elif row_diff < 0:  # if the other element is above                return 0, self.HEIGHT/2                        return 0, -self.HEIGHT/2  # default    def arrow_end_offset(self, other):        if other.grid_position is not None and self.grid_position is not None:            row_diff = self.grid_position[0] - other.grid_position[0]            col_diff = self.grid_position[1] - other.grid_position[1]            if col_diff > 0:  # if this element is to the right of the starting element                return -self.WIDTH/2, 0            elif col_diff < 0:  # if this element is to the left of the starting element                return self.WIDTH/2, 0            elif row_diff > 0:  # if this element is below the starting element                return 0, self.HEIGHT/2            elif row_diff < 0:  # if this element is above the starting element                return 0, -self.HEIGHT/2                        return 0, self.HEIGHT/2  # default# Represents a start or stop element in the flowchart, drawn as an ellipse.class StartStop(FlowElement):    WIDTH = 0.1  # The width of the ellipse    HEIGHT = 0.1  # The height of the ellipse    # Draws the start/stop ellipse and its label on the canvas.    def draw(self, ax, x, y, text_size):        ellipse = patches.Ellipse((x, y), self.WIDTH, self.HEIGHT, edgecolor='black', facecolor='none')        ax.add_patch(ellipse)        ax.text(x, y, self.label, horizontalalignment='center', verticalalignment='center', fontsize=text_size)            def arrow_start_offset(self, other):        if other.grid_position is not None and self.grid_position is not None:            row_diff = other.grid_position[0] - self.grid_position[0]            col_diff = other.grid_position[1] - self.grid_position[1]            if col_diff > 0:  # if the other element is to the right                return self.WIDTH/2, 0            elif col_diff < 0:  # if the other element is to the left                return -self.WIDTH/2, 0            elif row_diff > 0:  # if the other element is below                return 0, -self.HEIGHT/2            elif row_diff < 0:  # if the other element is above                return 0, self.HEIGHT/2                        return 0, -self.HEIGHT/2  # default    def arrow_end_offset(self, other):        # Same as Process's arrow_end_offset or customize if needed        if other.grid_position is not None and self.grid_position is not None:            row_diff = self.grid_position[0] - other.grid_position[0]            col_diff = self.grid_position[1] - other.grid_position[1]            if col_diff > 0:                return -self.WIDTH/2, 0            elif col_diff < 0:                return self.WIDTH/2, 0            elif row_diff > 0:                return 0, self.HEIGHT/2            elif row_diff < 0:                return 0, -self.HEIGHT/2                        return 0, self.HEIGHT/2        # Represents a decision element in the flowchart, drawn as a diamond.class Decision(FlowElement):    WIDTH = 0.15  # The width of the diamond    HEIGHT = 0.15  # The height of the diamond    # Draws the decision diamond and its label on the canvas.    def draw(self, ax, x, y, text_size):        polygon = patches.Polygon([[x, y - self.HEIGHT/2],                                    [x + self.WIDTH/2, y],                                    [x, y + self.HEIGHT/2],                                    [x - self.WIDTH/2, y]],                                   closed=True, edgecolor='black', facecolor='none')        ax.add_patch(polygon)        ax.text(x, y, self.label, horizontalalignment='center', verticalalignment='center', fontsize=text_size)            def arrow_start_offset(self, other):        if other.grid_position is not None and self.grid_position is not None:            row_diff = other.grid_position[0] - self.grid_position[0]            col_diff = other.grid_position[1] - self.grid_position[1]            if col_diff > 0:  # if the other element is to the right                return self.WIDTH/2, 0            elif col_diff < 0:  # if the other element is to the left                return -self.WIDTH/2, 0            elif row_diff > 0:  # if the other element is below                return 0, -self.HEIGHT/2            elif row_diff < 0:  # if the other element is above                return 0, self.HEIGHT/2                        return 0, -self.HEIGHT/2  # default    def arrow_end_offset(self, other):        if other.grid_position is not None and self.grid_position is not None:            row_diff = self.grid_position[0] - other.grid_position[0]             col_diff = self.grid_position[1] - other.grid_position[1]             if col_diff > 0:  # if this element is to the right of the starting element                return -self.WIDTH/2, 0            elif col_diff < 0:  # if this element is to the left of the starting element                return self.WIDTH/2, 0            elif row_diff > 0:  # if this element is below the starting element                return 0, self.HEIGHT/2            elif row_diff < 0:  # if this element is above the starting element                return 0, -self.HEIGHT/2                        return 0, self.HEIGHT/2  # default